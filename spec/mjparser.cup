package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import java.io.*;
import java.util.*;
import org.apache.log4j.*;
import rs.etf.pp1.mj.runtime.*;
import rs.etf.pp1.symboltable.*;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.structure.*;

parser code {:
    boolean errorDetected = false;
    int globalVarCharDecl = 0;
    int globalArrayDecl = 0;
    int globalMethodCount = 0;
    int classCount = 0;
    int statementBlockCount = 0;
    int methodCallsInMainCount = 0;
    int newStatementCount = 0;
    int classMethodCount = 0;
    int classFieldCount = 0;
    int inheritenceCount = 0;

    Logger log = Logger.getLogger(getClass());

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
        done_parsing();
        report_error(message, info);
    }
    
    public void syntax_error(Symbol cur_token) {
        report_error("Syntax error", cur_token);
    }
    
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error, parsing cannot be continued", cur_token);
    }
    
    public void report_error(String message, Object info) {
        errorDetected = true;
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            msg.append(" in line ").append(((Symbol)info).left);
        }
        
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
        StringBuilder msg = new StringBuilder(message);
        if (info instanceof Symbol) {
            msg.append(" in line ").append(((Symbol)info).left);
        }
        
        log.info(msg.toString());
    }
:}

scan with {:
    Symbol s = this.getScanner().next_token();
    if (s != null && s.value != null) {
        log.info(s.toString() + " " + s.value.toString());
    }
        
    return s;
:}

init with {:
	Tab.init();
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "bool", CUP$MJParser$actions.boolType));
    Tab.currentScope.addToLocals(new Obj(Obj.Type, "string", CUP$MJParser$actions.stringType));
:}

action code {:
	Obj currentMethod = Tab.noObj;
    Obj currentClass = Tab.noObj;
	Struct currentType = Tab.noType;
    Boolean inClass = false;
    Boolean inMethod = false;
    Boolean inLoop = false;

    Boolean mainFound = false;
	boolean returnFound = false;
    public static final int String = 6;
        
    public static final Struct boolType = new Struct(Struct.Bool);
    public static final Struct stringType = new Struct(String);
:}

terminal PROGRAM, BREAK, CLASS, CONST, ELSE, EXTENDS, IF, NEW, PRINT, READ, RETURN, VOID, WHILE ;

terminal Integer    NUMBER ;
terminal Character  CHAR ;
terminal Boolean    BOOL ;
terminal String     IDENT ;
terminal String     STRING ;

terminal PLUS, MINUS, MULT, DIV, MOD, EQEQ, NOTEQ, GT, GTEQ, LT, LTEQ, ANDAND, OROR, EQ, PLUSPLUS, MINUSMINUS;
terminal SEMICOLON, COMMA, DOT, LPAREN, RPAREN, LBRACK, RBRACK, LBRACE, RBRACE ;

non terminal Program ;
non terminal Decl, DeclList ;
non terminal ConstTemp, ConstList, ConstDecl ;
non terminal ClassVarMethodDeclList, ClassDecl, ClassCloseDecl ;
non terminal MethodName, MethodPars, MethodVarDeclList, MethodDecl, MethodType, MethodDeclList ;
non terminal Var, VarDecl, VarDeclListTemp, VarDeclList ;
non terminal LocalVarDeclList, LocalVarDecl, LocalVarDeclListTemp;
non terminal FormPar ;
non terminal Matched, Unmatched, Statement, StatementList ;
non terminal CondFact, CondTerm, Condition ;
non terminal EnterLoop, ExitLoop ;

non terminal Obj ProgramName ;
non terminal Obj ConstType ;
non terminal Obj ClassName ;
non terminal Integer FormPars ;
non terminal Obj Designator ;
non terminal Struct MethodCall, Factor, Term, ExprTemp, Expr, Type ;
non terminal LinkedList<Struct> ActPars, MethodSignature ;
non terminal Integer Addop, Mulop, Relop ;

/* ================ Program ==================== */
/* Program = "program" ident {ConstDecl | VarDecl | ClassDecl} "{" {MethodDecl} "}". */

Program     ::= PROGRAM ProgramName:p DeclList LBRACE MethodDeclList RBRACE
				{:
					Tab.chainLocalSymbols(p);
					Tab.closeScope();
                    if (!mainFound) {
                        parser.report_error("Semantical error: Program must contain \'main\' method", null);
                    }
				:}
				;

ProgramName ::= IDENT:progName
				{:
					RESULT = Tab.insert(Obj.Prog, progName, Tab.noType);
					Tab.openScope();
				:}
				;

DeclList    ::= DeclList Decl
                |
                /* epsilon */
                ;
                            
Decl        ::= ConstDecl
                |
                VarDecl
                |
                ClassDecl
                ;                    
/* ================ Program ==================== */


/* ================ ConstDecl ================== */
/* ConstDecl = "const" Type ident"="(num | charVal | boolVal | strVal) {, ident "=" ( num | charVal | boolVal | strVal)} ";" */

ConstDecl   ::= CONST Type ConstList SEMICOLON ;

ConstDecl   ::= CONST error:e SEMICOLON 
                {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from constant definition until \';\'."); :}
                ;  

ConstList   ::= ConstList COMMA ConstTemp
                |
                ConstTemp
                ;

ConstTemp   ::= IDENT:constName EQ ConstType:t
                {:
                    Obj obj = Tab.currentScope().findSymbol(constName);
                    if (obj != null) {
                        parser.report_error("Semantical error in line " + constNameleft + " : Constant \'" + constName + "\' already declared", null);
                    } else if (currentType != t.getType()) {
                        parser.report_error("Semantical error in line " + constNameleft + " : Incompatible type for constant \'" + constName + "\'", null);
                    } else {
                        parser.log.info("Constant declared \'" + constName + "\' in line " + constNameleft);
                        Obj o = Tab.insert(Obj.Con, constName, currentType);
                        o.setAdr(t.getAdr());
                    }
                :}
                ;

ConstType   ::= NUMBER:i
                {:
                    RESULT = new Obj(Obj.Con, "", Tab.intType);
                    RESULT.setAdr((i.intValue()));
                :}
                |
                CHAR:c
                {:
                    RESULT = new Obj(Obj.Con, "", Tab.charType);
                    RESULT.setAdr(c);
                :}
                |
                BOOL:b
                {:
                    RESULT = new Obj(Obj.Con, "", boolType);
                    RESULT.setAdr(b ? 1 : 0);
                :}
                |
                STRING:s
                {:
                    RESULT = new Obj(Obj.Con, "", stringType);
                :}
                ;
/* ================ ConstDecl ================== */


/* ================ VarDecl ==================== */
/* VarDecl = Type ident ["[" "]"] {"," ident ["[" "]"]} ";" */

VarDeclList 		::= VarDeclList VarDecl
						|
						VarDecl
						;

VarDecl				::= Type VarDeclListTemp ;
                
VarDeclListTemp 	::= Var COMMA VarDeclListTemp
						|
		                Var SEMICOLON
		                ;
		                
VarDeclListTemp 	::= error:e COMMA VarDeclListTemp
						{: parser.log.debug("Successful syntax error recovery in line " + eleft + " from variable definition until \',\'"); :}
		                |
		                error:e SEMICOLON
		                {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from variable definition until \';\'"); :}
		                ;

Var					::= IDENT:varName LBRACK RBRACK
						{:
                            Obj obj = Tab.currentScope().findSymbol(varName);
                            if (obj != null) {
                                parser.report_error("Semantical error in line " + varNameleft + " : Variable \'" + varName + "\' already declared", null);
                            } else {
    							parser.log.info("Variable declared \'" + varName + "\'[] in line " + varNameleft);
    							int objKind = inClass && !inMethod ? Obj.Fld : Obj.Var;
                                Tab.insert(objKind, varName, new Struct(Struct.Array, currentType));
                                if (!inClass && !inMethod) {
                                    parser.globalArrayDecl++;
                                    Code.dataSize++;
                                }

                                if (objKind == Obj.Fld) {
                                    parser.classFieldCount++;
                                }
                            }
						:}
						|
						IDENT:varName
						{:
                            Obj obj = Tab.currentScope().findSymbol(varName);
                            if (obj != null) {
                                parser.report_error("Semantical error in line " + varNameleft + " : Variable \'" + varName + "\' already declared", null);
                            } else {
    							parser.log.info("Variable declared \'" + varName + "\' in line " + varNameleft);
    							int objKind = inClass && !inMethod ? Obj.Fld : Obj.Var;
                                Tab.insert(objKind, varName, currentType);
                                if (!inClass && !inMethod) {
                                    Code.dataSize++;
                                    if (currentType == Tab.charType) {
                                        parser.globalVarCharDecl++;
                                    }
                                }

                                if (objKind == Obj.Fld) {
                                    parser.classFieldCount++;
                                }
                            }
						:}
						;
/* ================ VarDecl ==================== */


/* ================ LocalVarDecl ==================== */
LocalVarDeclList        ::= LocalVarDeclList LocalVarDecl
                            |
                            LocalVarDecl
                            ;

LocalVarDecl            ::= Type LocalVarDeclListTemp ;
                
LocalVarDeclListTemp    ::= Var COMMA LocalVarDeclListTemp
                            |
                            Var SEMICOLON
                            ;
                        
LocalVarDeclListTemp    ::= error:e SEMICOLON
                            {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from local variable definition until \';\'"); :}
                            |
                            error:e
                            {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from local variable definition until \'{\'"); :}
                            ;
/* ================ LocalVarDecl ==================== */


/* ================ ClassDecl ================== */
/* ClassDecl = "class" ident ["extends" Type] "{" {VarDecl} ["{" {MethodDecl} "}"] "}" */

ClassDecl               ::= CLASS ClassName LBRACE ClassVarMethodDeclList RBRACE ClassCloseDecl
                            |
                            CLASS ClassName EXTENDS IDENT:baseName
                            {:
                                Obj baseClass = Tab.find(baseName);
                                if (baseClass == Tab.noObj || baseClass.getType().getKind() != Struct.Class) {
                                    parser.report_error("Semantical error in line " + baseNameleft + " : Identifier \'" + baseName + "\' does not represent a class", null);
                                } else {
                                    for(Obj obj : baseClass.getType().getMembers()) {
                                        Obj o = Tab.insert(obj.getKind(), "super." + obj.getName(), obj.getType());
                                        if (obj.getKind() == Obj.Meth) {
                                            o.setLevel(obj.getLevel());
                                            HashTableDataStructure symbols = new HashTableDataStructure();
                                            for(Obj param : obj.getLocalSymbols()) {
                                                symbols.insertKey(param);
                                            }

                                            o.setLocals(symbols);
                                        }
                                    }
                                }

                                parser.inheritenceCount++;
                            :}
                            LBRACE ClassVarMethodDeclList RBRACE ClassCloseDecl
                            ;
                            
ClassDecl               ::= CLASS ClassName EXTENDS error:e LBRACE ClassVarMethodDeclList RBRACE ClassCloseDecl
                            {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from class definition until \'{\'"); :}
                            ;
                            
ClassName               ::= IDENT:className
                            {:
                                inClass = true;
                                currentClass = Tab.insert(Obj.Type, className, new Struct(Struct.Class));
                                Tab.openScope();
                                parser.log.info("Class declared \'" + className + "\' in line " + classNameleft);
                                parser.classCount++;
                            :}
                            ;

ClassCloseDecl          ::= {:
                                Tab.chainLocalSymbols(currentClass.getType());
                                Tab.closeScope();
                                inClass = false;
                            :}
                            ;

ClassVarMethodDeclList  ::= VarDeclList LBRACE MethodDeclList RBRACE
							|
							VarDeclList
                            |
                            LBRACE MethodDeclList RBRACE
                            |
                            /* epsilon */
                            ;

ClassVarMethodDeclList  ::= error:e
                            {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from class definition until \'}\'"); :}
                            ;                            
/* ================ ClassDecl ================== */


/* ================ MethodDecl ================= */
/* MethodDecl = (Type | "void") ident "(" [FormPars] ")" {VarDecl} "{" {Statement} "}" */

MethodDeclList      ::= MethodDeclList MethodDecl
                        |
                        /* epsilon */
                        ;
                            
MethodDecl          ::= MethodType MethodName LPAREN MethodPars RPAREN MethodVarDeclList LBRACE
                        {:
                            Code.put(Code.enter);
                            int paramCount = currentMethod.getLevel();
                            Code.put(paramCount);
                            Code.put(Tab.currentScope().getnVars());
                        :}
                        StatementList RBRACE
                        {:                            
                            if (!returnFound && currentMethod.getType() != Tab.noType && !currentMethod.getName().equals("main")) {
                                parser.report_error("Semantical error: Function \'" + currentMethod.getName() + "\' does not have return statement", null);
                            }
                            
                            Code.put(Code.exit);
                            Code.put(Code.return_);
                            Tab.chainLocalSymbols(currentMethod);
                            Tab.closeScope();
                            returnFound = false;
                            inMethod = false;
                            currentMethod = Tab.noObj;
                            parser.statementBlockCount++;
                        :}
                        ;
                        
MethodType          ::= Type
                        |
                        VOID
                        {: currentType = Tab.noType; :}
                        ;
						
MethodName          ::= IDENT:methodName
						{:
                            inMethod = true;
                            Obj obj = Tab.currentScope().findSymbol(methodName);
                            if (obj != null && obj.getKind() == Obj.Meth) {
                                parser.report_error("Semantical error in line " + methodNameleft + " : Method \'" + methodName + "\' already declared", null);
                                currentMethod = obj;
                            } else {
                                currentMethod = Tab.insert(Obj.Meth, methodName, currentType);
                                currentMethod.setAdr(Code.pc);
                                if ("main".equals(methodName) && !inClass) {
                                    mainFound = true;
                                    Code.mainPc = Code.pc;
                                    if (currentType != Tab.noType) {
                                        parser.report_error("Semantical error: Function 'main' must have 'void' return type", null);
                                    }
                                }
                            }

							Tab.openScope();
							parser.report_info("Processing method \'" + methodName + "\' in line " + methodNameleft, null);

                            if (!inClass) {
                                parser.globalMethodCount++;
                            } else {
                                parser.classMethodCount++;
                            }
						:}
						;

MethodPars          ::= FormPars:parCount
                        {: currentMethod.setLevel(parCount); :}
                        |
                        /* epsilon */
                        {: currentMethod.setLevel(0); :}
                        ;

MethodPars          ::= error:e
                        {:
                            currentMethod.setLevel(0);
                            parser.log.debug("Successful syntax error recovery in line " + eleft + " in formal parameters until \')\'");
                        :}
                        ;

MethodVarDeclList   ::= LocalVarDeclList
                        |
                        /* epsilon */
                        ;
                        
MethodCall          ::= Designator:func MethodSignature:sign
						{:
                            String funcName = func.getName().substring(func.getName().lastIndexOf('.') + 1);
							if (func.getKind() == Obj.Meth) {
								parser.report_info("Method call found \'" + funcName + "\' in line " + funcleft, null);
                                if(sign.size() != func.getLevel()) {
                                    parser.report_error("Semantical error in line " + funcleft + " : "
                                        + "Parameter count mismatch for function \'" + funcName + "\'", null);
                                } else {
                                    for(Obj param : func.getLocalSymbols()) {
                                        if (sign.size() == 0) {
                                            break;
                                        }

                                        if (!sign.removeFirst().assignableTo(param.getType())) {
                                            parser.report_error("Semantical error in line " + funcleft + " : "
                                                + "Incompatible parameter type for function \'" + funcName + "\'", null);
                                        }
                                    }                                    
                                }                                

								RESULT = func.getType();
                                if (currentMethod.getName().equals("main") && !inClass) {
                                    parser.methodCallsInMainCount++;
                                }
							}
							else {
								parser.report_error("Semantical error in line " + funcleft + " : Identifier \'" + funcName + "\' is not a function", null);
								RESULT = Tab.noType;
							}
						:}
						;

MethodSignature     ::= LPAREN ActPars:ap RPAREN
                        {: RESULT = ap; :}
                        |
                        LPAREN RPAREN
                        {: RESULT = new LinkedList<Struct>(); :}
                        ;
                        
MethodSignature		::=	LPAREN error:e RPAREN
                        {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from function call until \')\'"); :}
                        ;
/* ================ MethodDecl ================= */


/* ================ FormPars =================== */
/* FormPars = Type ident ["[" "]"] {"," Type ident ["[" "]"]} */

FormPars    ::= FormPar COMMA FormPars:parCount
                {: RESULT = parCount + 1; :}
                |
                FormPar
                {: RESULT = 1; :}
                ;
				
FormPars	::= error:e COMMA FormPars:parCount
				{:
                    RESULT = parCount + 1;
                    parser.log.debug("Successful syntax error recovery in line " + eleft + " in formal parameters until \',\'");
                :}
                |
                FormPar COMMA error:e
                {:
                    RESULT = 1;
                    parser.log.debug("Successful syntax error recovery in line " + eleft + " in formal parameters until \')\'");
                :}
                ;

FormPar     ::= Type IDENT:name LBRACK RBRACK
                {:
                    Tab.insert(Obj.Var, name, new Struct(Struct.Array, currentType));
                :}
                |
                Type IDENT:name
                {:
                    Tab.insert(Obj.Var, name, currentType);
                :}
                ;
/* ================ FormPars =================== */


/* ================ Type ======================= */
/* Type = ident */

Type    ::= IDENT:typeName
			{:
			 	Obj typeNode = Tab.find(typeName);
				if (typeNode == Tab.noObj) {
					parser.report_error("Semantical error in line " + typeNameleft + " : Type \'" + typeName + "\' not found in the symbols table", null);
					currentType = Tab.noType;
					RESULT = Tab.noType;
				}
				else {
					if (Obj.Type == typeNode.getKind()) {
						currentType = typeNode.getType();
						RESULT = typeNode.getType();
					}
					else {
						parser.report_error("Semantical error in line " + typeNameleft + " : Identifier \'" + typeName + "\' does not represent a type", null);
						currentType = Tab.noType;
						RESULT = Tab.noType;
					}
				}
		 	:}
		 	;
/* ================ Type ======================= */


/* ================ Statement ================== */
/* 
	Statement = Designator ("=" Expr | "(" [ActPars] ")" | "++" | "--") ";"
				| "if" "(" Condition ")" Statement ["else" Statement]
				| "while" "(" Condition ")" Statement
				| "break" ";"
				| "return" [Expr] ";"
				| "read" "(" Designator ")" ";"
				| "print" "(" Expr ["," number] ")" ";"
				| "{" {Statement} "}".
*/

StatementList   ::= StatementList Statement
                    |
                    /* epsilon */
                    ;

Statement       ::= Matched
                    |
                    Unmatched
                    ;
                        
Matched         ::= Designator:d EQ Expr:e SEMICOLON
					{:
                        if (d.getKind() == Obj.Con) {
                            parser.report_error("Semantical error in line " + dleft + " : Cannot assign value to a constant", null);
                        } else if ((d.getType().getKind() != Struct.Class || e.getKind() != Struct.Class) && !e.assignableTo(d.getType())) {
							parser.report_error("Semantical error in line " + dleft + " : Incompatible types", null);
						} else {
                            Code.store(d);
                        }
					:}
                    |
                    MethodCall SEMICOLON
                    |
                    Designator:d PLUSPLUS SEMICOLON
                    {:
                        if (d.getKind() == Obj.Con || d.getType() != Tab.intType) {
                            parser.report_error("Semantical error in line " + dleft + " : Unary operator \'++\' only applicable to non-const int type", null);
                        }

                        Code.load(d);
                        Code.put(Code.const_1);
                        Code.put(Code.add);
                        Code.store(d);
                    :}
                    |
                    Designator:d MINUSMINUS SEMICOLON
                    {:
                        if (d.getKind() == Obj.Con || d.getType() != Tab.intType) {
                            parser.report_error("Semantical error in line " + dleft + " : Unary operator \'--\' only applicable to non-const int type", null);
                        }

                        Code.load(d);
                        Code.put(Code.const_1);
                        Code.put(Code.sub);
                        Code.store(d);
                    :}
                    |
                    IF LPAREN Condition RPAREN Matched ELSE Matched
                    |
                    WHILE LPAREN Condition RPAREN EnterLoop Matched ExitLoop
                    |
                    BREAK:b SEMICOLON
                    {:
                        if (!inLoop) {
                            parser.report_error("Semantical error in line " + bleft + " : Breat statement must be used inside of a loop", null);
                        } else {
                            inLoop = false;
                        }

                    :}
                    |
                    RETURN Expr:t SEMICOLON
                    {:
                    	returnFound = true;
                    	Struct currentMethodType = currentMethod.getType();
                    	if (!currentMethodType.compatibleWith(t)) {
                    		parser.report_error("Semantical error in line " + tleft + " : Incompatible types", null);
                    	}
                    :}
                    |
                    RETURN:r SEMICOLON
                    {:
                    	returnFound = true;
                    	Struct currentMethodType = currentMethod.getType();
                    	if (!currentMethodType.compatibleWith(Tab.noType)) {
                    		parser.report_error("Semantical error in line " + rleft + " : Incompatible types", null);
                    	}
                    :}
                    |
                    READ LPAREN Designator:d RPAREN SEMICOLON
                    {:
                        if (d.getKind() == Obj.Con) {
                            parser.report_error("Semantical error in line " + dleft + " : Must pass a non-const variable to \'read\'", null);
                        } else if (d.getType() != Tab.intType && d.getType() != Tab.charType && d.getType() != boolType && d.getType() != stringType) {
                            parser.report_error("Semantical error in line " + dleft + " : Invalid parameter type for \'read\'", null);
                        }

                        if (currentMethod.getName().equals("main") && !inClass) {
                            parser.methodCallsInMainCount++;
                        }

                        Code.put(d.getType() != Tab.charType ? Code.read : Code.bread);
                        Code.store(d);
                    :}
                    |
                    PRINT LPAREN Expr:e COMMA NUMBER:i RPAREN SEMICOLON
                    {:
                        if (e != Tab.intType && e != Tab.charType && e != boolType &&e != stringType) {
                            parser.report_error("Semantical error in line " + eleft + " : Invalid parameter type for \'print\'", null);
                        }

                        if (currentMethod.getName().equals("main") && !inClass) {
                            parser.methodCallsInMainCount++;
                        }

                        Code.loadConst(i.intValue());
                        Code.put(e != Tab.charType ? Code.print : Code.bprint);
                    :}
                    |
                    PRINT LPAREN Expr:e RPAREN SEMICOLON
                    {:
                        if (e != Tab.intType && e != Tab.charType && e != boolType && e != stringType) {
                            parser.report_error("Semantical error in line " + eleft + " : Invalid parameter type for \'print\'", null);
                        }

                        if (currentMethod.getName().equals("main") && !inClass) {
                            parser.methodCallsInMainCount++;
                        }

                        Code.loadConst(Code.const_n + 0);
                        Code.put(e != Tab.charType ? Code.print : Code.bprint);
                    :}
                    |
                    LBRACE StatementList RBRACE
                    {: parser.statementBlockCount++; :}
                    ;
                    
Matched			::= Designator EQ error:e SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from assignment statement."); :}
                    |
                    error:e EQ Expr SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from assignment statement."); :}
                    |
                    Designator LPAREN error:e SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from function call until \';\'."); :}
                    |
                    READ LPAREN error:e SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from function call until \';\'."); :}
                    |
                    READ LPAREN error:e RPAREN SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from function call until \')\'."); :}
                    |
                    PRINT LPAREN error:e SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from function call until \';\'."); :}
                    |
                    PRINT LPAREN error:e RPAREN SEMICOLON
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from function call until \')\'."); :}
                    |
                    IF LPAREN error:e RPAREN Matched ELSE Matched
                    {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from invalid condition expression until \')\'"); :}
                    |
                    WHILE LPAREN error:e RPAREN EnterLoop Matched ExitLoop
                    {:
                        parser.log.debug("Successful syntax error recovery in line " + eleft + " from invalid condition expression until \')\'");
                    :}
                    ;
                    
Unmatched       ::= IF LPAREN Condition RPAREN Statement
					|
                    IF LPAREN Condition RPAREN Matched ELSE Unmatched
                    |
                    WHILE LPAREN Condition RPAREN EnterLoop Unmatched ExitLoop
                    ;
                    
Unmatched		::= IF LPAREN error:e RPAREN Statement
					{: parser.log.debug("Successful syntax error recovery in line " + eleft + " from invalid condition expression until \')\'"); :}
                    |
                    IF LPAREN error:e RPAREN Matched ELSE Unmatched
					{: parser.log.debug("Successful syntax error recovery in line " + eleft + " from invalid condition expression until \')\'"); :}
                    |
                    WHILE LPAREN error:e RPAREN EnterLoop Unmatched ExitLoop
                    {:
                        parser.log.debug("Successful syntax error recovery in line " + eleft + " from invalid condition expression until \')\'");
                    :}
                    ;

EnterLoop       ::= {: inLoop = true; :} ;

ExitLoop        ::= {: inLoop = false; :} ;
/* ================ Statement ================== */


/* ================ ActPars ==================== */
/* ActPars = Expr {"," Expr} */

ActPars ::= ActPars:ap COMMA Expr:e
            {: 
                RESULT = ap;
                RESULT.add(e);  
            :}
            |
            Expr:e
            {: 
                RESULT = new LinkedList<Struct>();
                RESULT.add(e);  
            :}
            ;
/* ================ ActPars ==================== */


/* ================ Condition ================== */
/* Condition = CondTerm {"||" CondTerm} */

Condition   ::= Condition OROR CondTerm
                |
                CondTerm                
                ;
/* ================ Condition ================== */


/* ================ CondTerm =================== */
/* CondTerm = CondFact {"&&" CondFact} */

CondTerm    ::= CondTerm ANDAND CondFact
                |
                CondFact
                ;
/* ================ CondTerm =================== */


/* ================ CondFact =================== */
/* CondFact = Expr [Relop Expr] */

CondFact    ::= Expr:e1 Relop:op Expr:e2
                {:
                    if (!e1.compatibleWith(e2)) {
                        parser.report_error("Semantical error in line " + e1left + " : Incompatible types", null);
                    }

                    if (op != Code.eq && op != Code.ne) {
                        if (e1.getKind() == Struct.Class && e2.getKind() == Struct.Class) {
                            parser.report_error("Semantical error in line " + e1left + " : Only \'==\' and \'!=\' operators are applicable to class types", null);
                        }
                    }
                :}
                |
                Expr
                ;
/* ================ CondFact =================== */


/* ================ Expr ======================= */
/* Expr = ["-"] Term {Addop Term} */

Expr        ::= MINUS ExprTemp:e
				{:
                    if (e != Tab.intType) {
                        parser.report_error("Semantical error in line " + eleft + " : Unary operator \'-\' only applicable to int type", null);
                    }

                    Code.put(Code.neg);
					RESULT = e;
				:}
                |
                ExprTemp:e
                {:
					RESULT = e;
				:}
                ;

ExprTemp    ::= ExprTemp:e Addop:op Term:t
				{:
					if (!e.compatibleWith(t)) {
                        parser.report_error("Semantical error in line " + eleft + " : Incompatible types", null);
                        RESULT = Tab.noType;
                    }

                    if (op != Code.add) {
                        if (e != Tab.intType || t != Tab.intType) {
                            parser.report_error("Semantical error in line " + eleft + " : Variables must be int type", null);    
                        }
                    } else {
                        if ((e != Tab.intType || t != Tab.intType) && (e != stringType || t != stringType))  {
                            parser.report_error("Semantical error in line " + eleft + " : Variables must be int or string type", null);    
                        }
                    }

                    Code.put(op);
					RESULT = e;
				:}
                |
                Term:t
                {:
                	RESULT = t;
                :}
                ;
/* ================ Expr ======================= */


/* ================ Term ======================= */
/* Term = Factor {Mulop Factor} */

Term    ::= Term:t Mulop:op Factor:f
            {:
                if (t != Tab.intType || f != Tab.intType) {
                    parser.report_error("Semantical error in line " + tleft + " : Variables must be int type", null);
                }

                if(!t.compatibleWith(f)) {
                    parser.report_error("Semantical error in line " + tleft + " : Incompatible types", null);
                }

                Code.put(op);
                RESULT = t;
            :}
            |
            Factor:f
            {:
            	RESULT = f;
            :}
            ;
/* ================ Term ======================= */


/* ================ Factor ===================== */
/* Factor = Designator ["(" [ActPars] ")"] | number | charConst | strConst | "new" Type ["[" Expr "]"] | "(" Expr ")" */

Factor  ::= Designator:d
			{:
                Code.load(d);
            	RESULT = d.getType();
            :}
            |
            MethodCall:t
            {: RESULT = t; :}
            |
            ConstType:c
            {:
                Code.load(c);
                RESULT = c.getType();
            :}
            |
            NEW Type:t
            {:
                if (t.getKind() != Struct.Class) {
                    parser.report_error("Semantical error in line " + tleft + " : Type must represnt a class", null);
                }

                RESULT = t;
                parser.newStatementCount++;
            :}
            |
            NEW Type:t LBRACK Expr:e RBRACK
            {:
                if (e != Tab.intType) {
                    parser.report_error("Semantical error in line " + tleft + " : Indexer must be int type", null);
                }

                Code.put(Code.newarray);
                Code.put(currentType == Tab.charType ? 0 : 1);
                RESULT = new Struct(Struct.Array, t);
                parser.newStatementCount++;
            :}
            |
            LPAREN Expr:e RPAREN
            {: RESULT = e; :}
            ;
            
Factor  ::=	NEW Type LBRACK error:e RBRACK
            {: parser.log.debug("Successful syntax error recovery in line " + eleft + " from array indexing expression until \']\'"); :}
            ;
/* ================ Factor ===================== */


/* ================ Designator ================= */
/* Designator = ident {"." ident | "[" Expr "]"} */

Designator  ::= Designator:d DOT IDENT:name
				{:
                    Obj obj = Tab.noObj;
                    if (d.getType().getKind() == Struct.Class) {
                        for(Obj fld : d.getType().getMembers()) {
                            int maxInheritenceCount = 0;
                            String identName = name;
                            Boolean isFound = false;
                            do {
                                if(fld.getName().equals(identName)) {
                                    obj = fld;
                                    isFound = true;
                                    break;
                                }

                                identName = "super." + identName;
                            } while (maxInheritenceCount++ < 30);

                            if (isFound) {
                                Code.load(d);
                                break;
                            }
                        }
                    } else {
					   parser.report_error("Semantical error in line " + nameleft + " : Identifier \'" + d.getName() + "\' must be class type", null);
                    }

                	if (obj == Tab.noObj && d.getType().getKind() == Struct.Class) {
                		parser.report_error("Semantical error in line " + nameleft + " : Identifier \'" + name + "\' not declared in class \'" + d.getName() + "\'", null);
                	}
                	
                	RESULT = obj;
				:}
                |
                Designator:d LBRACK {: Code.load(d); :} Expr:e RBRACK
                {:
                    if (e != Tab.intType) {
                        parser.report_error("Semantical error in line " + dleft + " : Indexer must be int type", null);
                    }

                    if (d.getType() == stringType) {
                        RESULT = new Obj(Obj.Elem, "", Tab.charType);
                    } else if (d.getType().getKind() == Struct.Array) {
                        RESULT = new Obj(Obj.Elem, "", d.getType().getElemType());
                    } else {
                        parser.report_error("Semantical error in line " + dleft + " : Identifier \'" + d.getName() + "\' is not an array type", null);
                        RESULT = Tab.noObj;
                    }
				:}
                |
                IDENT:name
                {:
                    int maxInheritenceCount = 0;
                    String identName = name;                    
                	Obj obj = Tab.noObj;
                    do {
                        obj = Tab.find(identName);
                        identName = "super." + identName;
                    } while(obj  == Tab.noObj && maxInheritenceCount++ < 30);

                	if (obj == Tab.noObj) {
                		parser.report_error("Semantical error in line " + nameleft + " : Identifier \'" + name + "\' not declared", null);
                	}
                	
                	RESULT = obj;
                :}
                ;
                
Designator  ::=	Designator:d LBRACK error:e RBRACK
                {:
                    parser.log.debug("Successful syntax error recovery in line " + eleft + " from array indexing expression until \']\'");
                    if(d.getType() == stringType) {
                        RESULT = new Obj(Obj.Elem, "", Tab.charType);
                    } else if (d.getType().getKind() == Struct.Array) { 
                        RESULT = new Obj(Obj.Elem, "", d.getType().getElemType());
                    } else {
                        parser.report_error("Semantical error in line " + dleft + " : Identifier \'" + d.getName() + "\' is not an array type", null);
                        RESULT = Tab.noObj;
                    }
                :}
                ;
/* ================ Designator ================= */


/* ================ Relop ====================== */
/* Relop = "==" | "!=" | ">" | ">=" | "<" | "<=" */

Relop   ::= EQEQ
            {:
                RESULT = Code.eq;
            :}
            |
            NOTEQ
            {:
                RESULT = Code.ne;
            :}
            |
            GT
            {:
                RESULT = Code.gt;
            :}
            |
            GTEQ
            {:
                RESULT = Code.ge;
            :}
            |
            LT
            {:
                RESULT = Code.lt;
            :}
            |
            LTEQ
            {:
                RESULT = Code.le;
            :}
            ;
/* ================ Relop ====================== */


/* ================ Addop ====================== */
/* Addop = "+" | "-" */

Addop   ::= PLUS
            {:
                RESULT = Code.add;
            :}
            |
            MINUS
            {:
                RESULT = Code.sub;
            :}
            ;
/* ================ Addop ====================== */


/* ================ Mulop ====================== */
/* Mulop = "*" | "/" | "%" */

Mulop   ::= MULT
            {:
                RESULT = Code.mul;
            :}
            |
            DIV
            {:
                RESULT = Code.div;
            :}
            |
            MOD
            {:
                RESULT = Code.rem;
            :}
            ;
/* ================ Mulop ====================== */
